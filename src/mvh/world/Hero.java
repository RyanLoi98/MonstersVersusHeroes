package mvh.world;

import mvh.enums.Direction;

/**
 * A Monster is an Entity with a user provide WEAPON STRENGTH and ARMOR STRENGTH
 * @author Ryan Loi
 * @author Jonathan Hudson
 * @date (dd / mm / yr): 28/02/22
 * @tutorial TO5 - Anika Achari
 * @version 1.0
 */
public final class Hero extends Entity {

    /**
     * The user provided weapon strength
     */
    private final int weaponStrength;

    /**
     * The user provided armor strength
     */
    private final int armorStrength;

    /**
     * A Hero has regular health and symbol as well as a weapon strength and armor strength
     *
     * @param health         Health of hero
     * @param symbol         Symbol for map to show hero
     * @param weaponStrength The weapon strength of the hero
     * @param armorStrength  The armor strength of the hero
     */
    public Hero(int health, char symbol, int weaponStrength, int armorStrength) {
        super(symbol, health);
        this.weaponStrength = weaponStrength;
        this.armorStrength = armorStrength;
    }

    /**
     * The weapon strength of monster is from user value
     *
     * @return The weapon strength of monster is from user value
     */
    @Override
    public int weaponStrength() {
        return weaponStrength;
    }

    /**
     * The armor strength of monster is from user value
     *
     * @return The armor strength of monster is from user value
     */
    @Override
    public int armorStrength() {
        return armorStrength;
    }

    /**
     * Can only be moved on top of if dad
     *
     * @return isDead()
     */
    @Override
    public boolean canMoveOnTopOf() {
        return isDead();
    }

    /**
     * Can only be attacked if alive
     *
     * @return isAlive()
     */
    @Override
    public boolean canBeAttacked() {
        return isAlive();
    }

    @Override
    public String toString() {
        return super.toString() + "\t" + weaponStrength + "\t" + armorStrength;
    }


    /**
     * Function that determines where this hero wants to attack based on local view of world (immediate neighbors that are
     * alive monsters in a 3x3 area around the hero)
     *
     * @param local The local view centered on the hero (immediate neighbors 3x3) generated by the world.getLocal
     *              function
     * @return The Direction the hero wants to attack (null if not attacking - i.e. no nearby alive monsters)
     */
    @Override
    public Direction attackWhere(World local) {
        // row and column index counter
        int row = 0;
        int column = 0;
        // correction factor to subtract from the row or column counter in order to receive the adjustment values for
        // the getDirection method
        int correctionFactor = 1;

        // loop from 0 to 2 which is the start and ending row index for a 3x3 grid
        while (row <= 2) {
            // loop from 0 to 2 which is the start and ending column index for a 3x3 grid
            while (column <= 2) {
                // ensure that we are not currently on index 1,1 which is where the grid is centered and where the hero is
                if (!(row == 1 && column == 1)) {
                    // if we aren't at index 1,1 check if this location contains a monster and if that monster is alive
                    if (local.isMonster(row, column) && local.getEntity(row, column).isAlive()){
                        // return direction (Direction.getDirection) if condition is met. The rowChange and columnChange
                        // arguments for getDirection is row or column - correction factor
                        return Direction.getDirection(row - correctionFactor, column - correctionFactor);
                    }
                }
                // increment column at end of each column
                column++;
            }
            // reset column back to 0 when reach the end of the columns before going to next row
            column = 0;
            // increment row
            row++;
        }
        // return null if hero did not find a monster to attack
        return null;
    }



    /**
     * Function that determine where does this hero want to move based on local view of world (5x5), and any Monsters
     * within this range dictates the direction the hero will move
     *
     * @param local  The local view centered on the hero (immediate neighbors 5x5) generated by the world.getLocal
     *               function
     * @return The Direction the hero wants to move, which will be in the direction of an alive monster
     * (presumption that entity already decided to not attack)
     */

    public Direction chooseMove(World local){

        // row and column index counter
        int row = 0;
        int column = 0;
        // correction factor to subtract from the row or column counter in order to receive the adjustment values for
        // the getDirection method
        int correctionFactor = 2;

        // hero indexes
        int heroRow = 2;
        int heroColumn = 2;

        // loop from 0 to 4 which is the start and ending row index for a 5x5 grid
        while (row <= 4) {
            // loop from 0 to 4 which is the start and ending column index for a 5x5 grid
            while (column <= 4) {
                // ensure that we are not currently within the 3x3 attack grid which means we are not in the rows of
                // index 1-3 and column index 1-3
                if (!(row>0 && row<4 && column>0 && column<4)) {
                    // if this is the case check if there is a monster in this spot that is alive
                    if (local.isMonster(row, column) && local.getEntity(row, column).isAlive()){
                        // get the directions that the hero can try to move
                        Direction[] directions = Direction.getDirections(row-correctionFactor, column-correctionFactor);
                        // test first direction (index 0) returned by the getDirections function, if can move there return it
                        if (local.canMoveOnTopOf(heroRow, heroColumn, directions[0])){
                            return directions[0];
                        }
                        // test first direction (index 1) returned by the getDirections function, if can move there return it
                        else if(local.canMoveOnTopOf(heroRow, heroColumn, directions[1])){
                            return directions[1];
                        }
                        // test first direction (index 2) returned by the getDirections function, if can move there return it
                        else if(local.canMoveOnTopOf(heroRow, heroColumn, directions[2])){
                            return directions[2];
                        }
                    }
                }
                // increment column at end of each column
                column++;
            }
            // reset column back to 0 when reach the end of the columns before going to next row
            column = 0;
            // increment row
            row++;
        }
        // if there are no monsters nearby in the 5x5 vicinity then move NorthWest if possible.
        if(local.canMoveOnTopOf(heroRow,heroColumn, Direction.NORTHWEST)){
            return Direction.NORTHWEST;
        }

        else {
            // get a random direction to move when hero cannot move NorthWest
            Direction randomDirection = Direction.getRandomDirection();
            // if hero cannot move North West try to move in a random direction
            // if random direction happens to be stay then stay
            if(randomDirection.equals(Direction.STAY)){
                return Direction.STAY;
            }
            //otherwise test if the random direction can be moved to, and if the answer is yes then return that direction
            else if (local.canMoveOnTopOf(heroRow, heroColumn, randomDirection)){
                return randomDirection;
            }
            // if hero cannot move in a random direction just stay
            else{
                return Direction.STAY;
            }

        }

    }

}
