package mvh.world;

import mvh.enums.Direction;
import mvh.enums.WeaponType;

/**
 * A Monster is an Entity with a set ARMOR STRENGTH and a user provided WEAPON TYPE
 * @author Ryan Loi
 * @author Jonathan Hudson
 * @date (dd / mm / yr): 28/02/22
 * @tutorial TO5 - Anika Achari
 * @version 1.0
 */
public final class Monster extends Entity {

    /**
     * The set armor strength of a Monster
     */
    private static final int MONSTER_ARMOR_STRENGTH = 2;

    /**
     * The user provided weapon type
     */
    private final WeaponType weaponType;

    /**
     * A Monster has regular health and symbol as well as a weapon type
     *
     * @param health     Health of Monster
     * @param symbol     Symbol for map to show Monster
     * @param weaponType The weapon type of the Monster
     */
    public Monster(int health, char symbol, WeaponType weaponType) {
        super(symbol, health);
        this.weaponType = weaponType;
    }

    /**
     * The weapon strength of monster is from their weapon type
     * @return The weapon strength of monster is from their weapon type
     */
    @Override
    public int weaponStrength() {
        return weaponType.getWeaponStrength();
    }

    /**
     * The armor strength of monster is from the stored constant
     * @return The armor strength of monster is from the stored constant
     */
    @Override
    public int armorStrength() {
        return MONSTER_ARMOR_STRENGTH;
    }

    /**
     * Can only be moved on top of if dad
     * @return isDead()
     */
    @Override
    public boolean canMoveOnTopOf() {
        return isDead();
    }

    /**
     * Can only be attacked if alive
     * @return isAlive()
     */
    @Override
    public boolean canBeAttacked() {
        return isAlive();
    }

    @Override
    public String toString() {
        return super.toString() + "\t" + weaponType;
    }

// ------------------------------------------fix-------------------------------------------------------
    /**
     * Function that determines where this monster wants to attack based on local view of world (immediate neighbors that are
     * alive heroes in a 3x3 area around the monster)
     *
     * @param local The local view centered on the monster (immediate neighbors 3x3) generated by the world.getLocal
     *              function
     * @return The Direction the monster wants to attack (null if not attacking - i.e. no nearby alive heroes)
     */
    @Override
    public Direction attackWhere(World local) {
        // row and column index counter, starts at 2 because we will loop from bottom to top and right to left
        int row = 2;
        int column = 2;
        // correction factor to subtract from the row or column counter in order to receive the adjustment values for
        // the getDirection method
        int correctionFactor = 1;

        // loop from 2 to 0 which is the from the ending to starting row index for a 3x3 grid
        while (row >= 0) {
            // loop from 2 to 0 which is the from the ending to starting column for a 3x3 grid
            while (column >= 0) {
                // ensure that we are not currently on index 1,1 which is where the grid is centered and where the monster is
                if (!(row == 1 && column == 1)) {
                    // if we aren't at index 1,1 check if this location contains a hero and if that hero is alive
                    if (local.isHero(row, column) && local.getEntity(row, column).isAlive()){
                        // return direction (Direction.getDirection) if condition is met. The rowChange and columnChange
                        // arguments for getDirection is row or column - correction factor
                        return Direction.getDirection(row - correctionFactor, column - correctionFactor);
                    }
                }
                // decrement column at end of each column
                column--;
            }
            // reset column back to 2 when reach the start of the columns before going to next row
            column = 2;
            // decrement row
            row--;
        }
        // return null if monster did not find a hero to attack
        return null;
    }



    /**
     * Function that determine where does this hero want to move based on local view of world (5x5), and any Monsters
     * within this range dictates the direction the hero will move
     *
     * @param local  The local view centered on the hero (immediate neighbors 5x5) generated by the world.getLocal
     *               function
     * @return The Direction the hero wants to move, which will be in the direction of an alive monster
     * (presumption that entity already decided to not attack)
     */

    public Direction chooseMove(World local){

        // row and column index counter starts at 4 because we will loop from bottom to top and right to left
        int row = 4;
        int column = 4;
        // correction factor to subtract from the row or column counter in order to receive the adjustment values for
        // the getDirection method
        int correctionFactor = 2;

        // monster indexes
        int monsterRow = 2;
        int monsterColumn = 2;

        // loop from 4 to 0 which is the ending to starting row index for a 5x5 grid
        while (row >= 0) {
            // loop from 4 to 0 which is the ending to starting column index for a 5x5 grid
            while (column >= 0) {
                // ensure that we are not currently within the 3x3 attack grid which means we are not in the rows of
                // index 1-3 and column index 1-3
                if (!(row>0 && row<4 && column>0 && column<4)) {
                    // if this is the case check if there is a hero in this spot that is alive
                    if (local.isHero(row, column) && local.getEntity(row, column).isAlive()){
                        // get the directions that the monster can try to move
                        Direction[] directions = Direction.getDirections(row-correctionFactor, column-correctionFactor);
                        // test first direction (index 0) returned by the getDirections function, if can move there return it
                        if (local.canMoveOnTopOf(monsterRow, monsterColumn, directions[0])){
                            return directions[0];
                        }
                        // test first direction (index 1) returned by the getDirections function, if can move there return it
                        else if(local.canMoveOnTopOf(monsterRow, monsterColumn, directions[1])){
                            return directions[1];
                        }
                        // test first direction (index 2) returned by the getDirections function, if can move there return it
                        else if(local.canMoveOnTopOf(monsterRow, monsterColumn, directions[2])){
                            return directions[2];
                        }
                    }
                }
                // decrement column at start of each column
                column--;
            }
            // reset column back to 4 when reach the end of the columns before going to next row
            column = 4;
            // decrement row
            row--;
        }

        // if there are no heroes nearby in the 5x5 vicinity then move SouthEast if possible.
        if(local.canMoveOnTopOf(monsterRow,monsterColumn, Direction.SOUTHEAST)){
            return Direction.SOUTHEAST;
        }

        else {
            // get a random direction to move when monster cannot move SouthEast
            Direction randomDirection = Direction.getRandomDirection();

            // if monster cannot move southEast try to move in a random direction
            // if random direction happens to be stay then stay
            if(randomDirection.equals(Direction.STAY)){
                return Direction.STAY;
            }
            //otherwise test if the random direction can be moved to, and if the answer is yes then return that direction
            else if (local.canMoveOnTopOf(monsterRow, monsterColumn, randomDirection)){
                return randomDirection;
            }
            // if monster cannot move in a random direction just stay
            else{
                return Direction.STAY;
            }

        }

    }
}
